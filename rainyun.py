import logging
import logging.handlers
import os
import random
import time
import schedule
import sys
from datetime import datetime, timedelta

# å…¨å±€å˜é‡ï¼Œç”¨äºå­˜å‚¨Seleniumæ¨¡å—
selenium_modules = None

def import_selenium_modules():
    """å¯¼å…¥Seleniumç›¸å…³æ¨¡å—"""
    global selenium_modules
    if selenium_modules is None:
        from selenium import webdriver
        from selenium.webdriver import ActionChains
        from selenium.webdriver.chrome.options import Options
        from selenium.webdriver.chrome.service import Service
        from selenium.webdriver.chrome.webdriver import WebDriver
        from selenium.webdriver.common.by import By
        from selenium.webdriver.support import expected_conditions as EC
        from selenium.webdriver.support.wait import WebDriverWait
        from selenium.common import TimeoutException
        
        selenium_modules = {
            'webdriver': webdriver,
            'ActionChains': ActionChains,
            'Options': Options,
            'Service': Service,
            'WebDriver': WebDriver,
            'By': By,
            'EC': EC,
            'WebDriverWait': WebDriverWait,
            'TimeoutException': TimeoutException
        }
    return selenium_modules

def unload_selenium_modules():
    """å¸è½½Seleniumç›¸å…³æ¨¡å—ï¼Œé‡Šæ”¾å†…å­˜"""
    global selenium_modules
    if selenium_modules is not None:
        # ä»sys.modulesä¸­ç§»é™¤Seleniumæ¨¡å—
        modules_to_remove = [
            'selenium',
            'selenium.webdriver',
            'selenium.webdriver.chrome',
            'selenium.webdriver.chrome.options',
            'selenium.webdriver.chrome.service',
            'selenium.webdriver.chrome.webdriver',
            'selenium.webdriver.common',
            'selenium.webdriver.common.by',
            'selenium.webdriver.support',
            'selenium.webdriver.support.expected_conditions',
            'selenium.webdriver.support.wait',
            'selenium.common'
        ]
        
        for module in modules_to_remove:
            if module in sys.modules:
                del sys.modules[module]
        
        selenium_modules = None


def setup_logging():
    """è®¾ç½®æ—¥å¿—è½®è½¬åŠŸèƒ½ï¼Œè‡ªåŠ¨æ¸…ç†7å¤©å‰çš„æ—¥å¿—"""
    # ç¡®ä¿æ—¥å¿—ç›®å½•å­˜åœ¨
    log_dir = "logs"
    os.makedirs(log_dir, exist_ok=True)
    
    # åˆ›å»ºæ—¥å¿—è½®è½¬å¤„ç†å™¨ï¼Œä¿ç•™7å¤©çš„æ—¥å¿—ï¼Œæ¯å¤©è½®è½¬ä¸€æ¬¡
    log_file = os.path.join(log_dir, "rainyun.log")
    file_handler = logging.handlers.TimedRotatingFileHandler(
        log_file,
        when='midnight',  # æ¯å¤©åˆå¤œè½®è½¬
        interval=1,  # æ¯å¤©è½®è½¬ä¸€æ¬¡
        backupCount=7,  # ä¿ç•™7å¤©çš„æ—¥å¿—
        encoding='utf-8'
    )
    
    # è®¾ç½®æ—¥å¿—æ ¼å¼
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    
    # åˆ›å»ºæ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    
    # è·å–æ ¹æ—¥å¿—è®°å½•å™¨
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    
    # æ·»åŠ å¤„ç†å™¨
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)
    
    # æ¸…ç†æ—§çš„æ—¥å¿—æ–‡ä»¶ï¼ˆè¶…è¿‡7å¤©çš„ï¼‰
    cleanup_old_logs(log_dir, days=7)
    
    # æ¸…ç†æ—§çš„æ—¥å¿—æ–‡ä»¶ï¼ˆè¶…è¿‡7å¤©çš„ï¼‰
    cleanup_old_logs(log_dir, days=7)
    
    return root_logger


# ==========================================
# Notification System
# ==========================================

class NotificationProvider:
    """é€šçŸ¥æä¾›è€…åŸºç±»"""
    def send(self, title, context):
        """
        å‘é€é€šçŸ¥
        :param title: æ ‡é¢˜
        :param context: å†…å®¹ä¸Šä¸‹æ–‡ï¼ŒåŒ…å« {'html': str, 'markdown': str}
        """
        raise NotImplementedError

class PushPlusProvider(NotificationProvider):
    """PushPlus æ¨é€æ¸ é“"""
    def __init__(self, token):
        self.token = token

    def send(self, title, context):
        import requests
        content = context.get('html', '')
        url = 'http://www.pushplus.plus/send'
        data = {
            "token": self.token,
            "title": title,
            "content": content,
            "template": "html"
        }
        try:
            logging.info(f"Sending PushPlus notification: {title}")
            response = requests.post(url, json=data, timeout=10)
            result = response.json()
            if result.get('code') == 200:
                logging.info("PushPlus notification sent successfully")
                return True
            else:
                logging.error(f"PushPlus notification failed: {result.get('msg')}")
                return False
        except Exception as e:
            logging.error(f"Error sending PushPlus notification: {e}")
            return False

class WXPusherProvider(NotificationProvider):
    """WXPusher æ¨é€æ¸ é“"""
    def __init__(self, app_token, uids):
        self.app_token = app_token
        self.uids = uids if isinstance(uids, list) else [uid.strip() for uid in uids.split(',') if uid.strip()]

    def send(self, title, context):
        import requests
        content = context.get('html', '')
        url = 'https://wxpusher.zjiecode.com/api/send/message'
        data = {
            "appToken": self.app_token,
            "content": content,
            "summary": title,
            "contentType": 2,  # 1=Text, 2=HTML
            "uids": self.uids
        }
        try:
            logging.info(f"Sending WXPusher notification: {title}")
            response = requests.post(url, json=data, timeout=10)
            result = response.json()
            if result.get('code') == 1000: # WXPusher success code is 1000
                logging.info("WXPusher notification sent successfully")
                return True
            else:
                logging.error(f"WXPusher notification failed: {result.get('msg')}")
                return False
        except Exception as e:
            logging.error(f"Error sending WXPusher notification: {e}")
            return False

class DingTalkProvider(NotificationProvider):
    """é’‰é’‰æœºå™¨äººæ¨é€æ¸ é“"""
    def __init__(self, access_token, secret=None):
        self.access_token = access_token
        self.secret = secret

    def send(self, title, context):
        import requests
        import time
        import hmac
        import hashlib
        import base64
        import urllib.parse
        
        content = context.get('markdown', '')
        # é’‰é’‰ Markdown éœ€è¦ title å­—æ®µ
        # content å¿…é¡»åŒ…å« titleï¼Œè¿™é‡Œç»„åˆä¸€ä¸‹
        md_text = f"# {title}\n\n{content}"
        
        url = 'https://oapi.dingtalk.com/robot/send'
        params = {'access_token': self.access_token}
        
        if self.secret:
            timestamp = str(round(time.time() * 1000))
            secret_enc = self.secret.encode('utf-8')
            string_to_sign = '{}\n{}'.format(timestamp, self.secret)
            string_to_sign_enc = string_to_sign.encode('utf-8')
            hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()
            sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))
            params['timestamp'] = timestamp
            params['sign'] = sign

        data = {
            "msgtype": "markdown",
            "markdown": {
                "title": title,
                "text": md_text
            }
        }
        
        try:
            logging.info(f"Sending DingTalk notification: {title}")
            response = requests.post(url, params=params, json=data, timeout=10)
            result = response.json()
            if result.get('errcode') == 0:
                logging.info("DingTalk notification sent successfully")
                return True
            else:
                logging.error(f"DingTalk notification failed: {result.get('errmsg')}")
                return False
        except Exception as e:
            logging.error(f"Error sending DingTalk notification: {e}")
            return False

class EmailProvider(NotificationProvider):
    """é‚®ä»¶æ¨é€æ¸ é“"""
    def __init__(self, host, port, user, password, to_email):
        self.host = host
        self.port = int(port)
        self.user = user
        self.password = password
        self.to_email = to_email

    def send(self, title, context):
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        from email.header import Header
        
        content = context.get('html', '')
        
        try:
            message = MIMEMultipart()
            message['From'] = f"Rainyun-Qiandao <{self.user}>"
            message['To'] = self.to_email
            message['Subject'] = Header(title, 'utf-8')
            
            message.attach(MIMEText(content, 'html', 'utf-8'))
            
            logging.info(f"Sending Email notification to {self.to_email}")
            
            # è¿æ¥ SMTP æœåŠ¡å™¨
            if self.port == 465:
                server = smtplib.SMTP_SSL(self.host, self.port)
            else:
                server = smtplib.SMTP(self.host, self.port)
                # å°è¯•å¯ç”¨ TLS
                try:
                    server.starttls()
                except:
                    pass
            
            server.login(self.user, self.password)
            server.sendmail(self.user, [self.to_email], message.as_string())
            server.quit()
            
            logging.info("Email notification sent successfully")
            return True
        except Exception as e:
            logging.error(f"Error sending Email notification: {e}")
            return False

class NotificationManager:
    """é€šçŸ¥ç®¡ç†å™¨"""
    def __init__(self):
        self.providers = []

    def add_provider(self, provider):
        self.providers.append(provider)

    def send_all(self, title, context):
        if not self.providers:
            logging.info("No notification providers configured.")
            return

        logging.info(f"Sending notifications to {len(self.providers)} providers...")
        for provider in self.providers:
            provider.send(title, context)


def cleanup_old_logs(log_dir, days=7):
    """æ¸…ç†è¶…è¿‡æŒ‡å®šå¤©æ•°çš„æ—¥å¿—æ–‡ä»¶"""
    try:
        now = time.time()
        cutoff = now - (days * 86400)  # 86400ç§’ = 1å¤©
        
        for filename in os.listdir(log_dir):
            file_path = os.path.join(log_dir, filename)
            if os.path.isfile(file_path) and filename.startswith('rainyun.log.'):
                file_time = os.path.getmtime(file_path)
                if file_time < cutoff:
                    os.remove(file_path)
                    logging.info(f"å·²åˆ é™¤è¿‡æœŸæ—¥å¿—æ–‡ä»¶: {filename}")
    except Exception as e:
        logging.error(f"æ¸…ç†æ—§æ—¥å¿—æ–‡ä»¶æ—¶å‡ºé”™: {e}")


def cleanup_logs_on_startup():
    """ç¨‹åºå¯åŠ¨æ—¶æ‰§è¡Œæ—¥å¿—æ¸…ç†"""
    log_dir = "logs"
    if not os.path.exists(log_dir):
        return
    
    try:
        # ç»Ÿè®¡å½“å‰æ—¥å¿—æ–‡ä»¶æ•°é‡å’Œå¤§å°
        log_files = [f for f in os.listdir(log_dir) if f.startswith('rainyun.log.')]
        total_size = sum(os.path.getsize(os.path.join(log_dir, f)) for f in log_files if os.path.isfile(os.path.join(log_dir, f)))
        
        if log_files:
            logging.info(f"æ£€æµ‹åˆ° {len(log_files)} ä¸ªå†å²æ—¥å¿—æ–‡ä»¶ï¼Œæ€»å¤§å°çº¦ {total_size / 1024 / 1024:.2f} MB")
            
            # å¦‚æœæ—¥å¿—æ–‡ä»¶è¿‡å¤šï¼Œæ‰§è¡Œæ¸…ç†
            if len(log_files) > 10:  # å¦‚æœè¶…è¿‡10ä¸ªæ—¥å¿—æ–‡ä»¶
                logging.info("å†å²æ—¥å¿—æ–‡ä»¶è¿‡å¤šï¼Œæ‰§è¡Œæ¸…ç†...")
                cleanup_old_logs(log_dir, days=7)
                
                # é‡æ–°ç»Ÿè®¡æ¸…ç†åçš„æƒ…å†µ
                remaining_files = [f for f in os.listdir(log_dir) if f.startswith('rainyun.log.')]
                remaining_size = sum(os.path.getsize(os.path.join(log_dir, f)) for f in remaining_files if os.path.isfile(os.path.join(log_dir, f)))
                logging.info(f"æ¸…ç†å®Œæˆï¼Œå‰©ä½™ {len(remaining_files)} ä¸ªæ—¥å¿—æ–‡ä»¶ï¼Œæ€»å¤§å°çº¦ {remaining_size / 1024 / 1024:.2f} MB")
    except Exception as e:
        logging.error(f"å¯åŠ¨æ—¶æ—¥å¿—æ¸…ç†å‡ºé”™: {e}")


def setup_sigchld_handler():
    """è®¾ç½®SIGCHLDä¿¡å·å¤„ç†å™¨ï¼Œè‡ªåŠ¨å›æ”¶å­è¿›ç¨‹ï¼Œé˜²æ­¢åƒµå°¸è¿›ç¨‹ç´¯ç§¯"""
    # å»¶è¿Ÿå¯¼å…¥signalæ¨¡å—
    import signal
    
    def sigchld_handler(signum, frame):
        """å½“å­è¿›ç¨‹é€€å‡ºæ—¶è‡ªåŠ¨å›æ”¶ï¼Œé˜²æ­¢å˜æˆåƒµå°¸è¿›ç¨‹"""
        while True:
            try:
                # éé˜»å¡åœ°å›æ”¶æ‰€æœ‰å·²é€€å‡ºçš„å­è¿›ç¨‹
                pid, status = os.waitpid(-1, os.WNOHANG)
                if pid == 0:  # æ²¡æœ‰æ›´å¤šå­è¿›ç¨‹éœ€è¦å›æ”¶
                    break
            except ChildProcessError:
                # æ²¡æœ‰å­è¿›ç¨‹äº†
                break
            except Exception:
                break
    
    if os.name == 'posix':  # ä»…åœ¨Linux/Unixç³»ç»Ÿä¸Šè®¾ç½®
        signal.signal(signal.SIGCHLD, sigchld_handler)
        logging.info("å·²è®¾ç½®å­è¿›ç¨‹è‡ªåŠ¨å›æ”¶æœºåˆ¶ï¼Œé˜²æ­¢åƒµå°¸è¿›ç¨‹ç´¯ç§¯")


def cleanup_zombie_processes():
    """æ¸…ç†å¯èƒ½æ®‹ç•™çš„ Chrome/ChromeDriver åƒµå°¸è¿›ç¨‹"""
    # å»¶è¿Ÿå¯¼å…¥subprocessæ¨¡å—
    import subprocess
    
    try:
        if os.name == 'posix':  # Linux/Unix ç³»ç»Ÿ
            # æŸ¥æ‰¾å¹¶æ¸…ç†åƒµå°¸ chrome å’Œ chromedriver è¿›ç¨‹
            try:
                result = subprocess.run(['pgrep', '-f', 'chrome|chromedriver'], 
                                      capture_output=True, text=True, timeout=5)
                if result.stdout:
                    pids = result.stdout.strip().split('\n')
                    zombie_count = 0
                    zombie_pids = []
                    parent_pids = set()
                    
                    for pid in pids:
                        if pid:
                            try:
                                # æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
                                stat_result = subprocess.run(['ps', '-p', pid, '-o', 'stat='], 
                                                           capture_output=True, text=True, timeout=2)
                                if 'Z' in stat_result.stdout:  # åƒµå°¸è¿›ç¨‹
                                    zombie_count += 1
                                    zombie_pids.append(pid)
                                    
                                    # è·å–çˆ¶è¿›ç¨‹PID
                                    ppid_result = subprocess.run(['ps', '-p', pid, '-o', 'ppid='], 
                                                               capture_output=True, text=True, timeout=2)
                                    if ppid_result.stdout:
                                        ppid = ppid_result.stdout.strip()
                                        if ppid and ppid != '1':  # ä¸å¤„ç†initè¿›ç¨‹çš„å­è¿›ç¨‹
                                            parent_pids.add(ppid)
                                            logger.warning(f"å‘ç°åƒµå°¸è¿›ç¨‹ PID: {pid}, çˆ¶è¿›ç¨‹: {ppid}")
                                        else:
                                            logger.warning(f"å‘ç°åƒµå°¸è¿›ç¨‹ PID: {pid}")
                            except:
                                pass
                    
                    if zombie_count > 0:
                        logger.info(f"æ£€æµ‹åˆ° {zombie_count} ä¸ªåƒµå°¸è¿›ç¨‹")
                        
                        # å°è¯•é€šè¿‡ waitpid å›æ”¶åƒµå°¸è¿›ç¨‹ï¼ˆéé˜»å¡ï¼‰
                        cleaned = 0
                        for zpid in zombie_pids:
                            try:
                                os.waitpid(int(zpid), os.WNOHANG)
                                cleaned += 1
                            except (ChildProcessError, ProcessLookupError, PermissionError, ValueError):
                                # ä¸æ˜¯å½“å‰è¿›ç¨‹çš„å­è¿›ç¨‹ï¼Œæ— æ³•ç›´æ¥å›æ”¶
                                pass
                        
                        if cleaned > 0:
                            logger.info(f"æˆåŠŸå›æ”¶ {cleaned} ä¸ªåƒµå°¸è¿›ç¨‹")
                        
                        # å¯¹äºæ— æ³•å›æ”¶çš„åƒµå°¸è¿›ç¨‹ï¼Œè®°å½•çˆ¶è¿›ç¨‹ä¿¡æ¯
                        if parent_pids:
                            logger.info(f"åƒµå°¸è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ PIDs: {', '.join(parent_pids)}")
                            logger.info("æç¤ºï¼šåƒµå°¸è¿›ç¨‹ç”±çˆ¶è¿›ç¨‹åˆ›å»ºï¼Œéœ€è¦çˆ¶è¿›ç¨‹è°ƒç”¨wait()å›æ”¶")
                            logger.info("è¿™äº›åƒµå°¸è¿›ç¨‹ä¸å ç”¨CPU/å†…å­˜ï¼Œé€šå¸¸ä¼šåœ¨çˆ¶è¿›ç¨‹ç»“æŸæ—¶è¢«initæ¥ç®¡å¹¶æ¸…ç†")
                        
                        # æ¸…ç†å¯èƒ½æ®‹ç•™çš„æ´»è·ƒChromeå­è¿›ç¨‹ï¼ˆéåƒµå°¸ï¼‰
                        subprocess.run(['pkill', '-9', '-f', 'chrome.*--type='], 
                                     timeout=5, stderr=subprocess.DEVNULL)
                        logger.info("å·²æ¸…ç†æ®‹ç•™çš„æ´»è·ƒ Chrome å­è¿›ç¨‹")
                    
            except subprocess.TimeoutExpired:
                logger.warning("è¿›ç¨‹æ¸…ç†è¶…æ—¶")
            except FileNotFoundError:
                # pgrep/pkill å‘½ä»¤ä¸å­˜åœ¨ï¼Œè·³è¿‡
                pass
            except Exception as e:
                logger.debug(f"æ¸…ç†è¿›ç¨‹æ—¶å‡ºç°å¼‚å¸¸ï¼ˆå¯å¿½ç•¥ï¼‰: {e}")
    except Exception as e:
        logger.debug(f"åƒµå°¸è¿›ç¨‹æ¸…ç†å¤±è´¥ï¼ˆå¯å¿½ç•¥ï¼‰: {e}")


def get_random_user_agent():
    """è·å–éšæœº User-Agent"""
    user_agents = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0"
    ]
    return random.choice(user_agents)


# SVGå›¾æ ‡
SVG_ICONS = {
    'success': '''<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#10B981" width="24" height="24"><path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z" clip-rule="evenodd" /></svg>''',
    'error': '''<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#EF4444" width="24" height="24"><path fill-rule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25zm-1.72 6.97a.75.75 0 10-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 101.06 1.06L12 13.06l1.72 1.72a.75.75 0 101.06-1.06L13.06 12l1.72-1.72a.75.75 0 10-1.06-1.06L12 10.94l-1.72-1.72z" clip-rule="evenodd" /></svg>''',
    'user': '''<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="#6B7280" width="20" height="20"><path fill-rule="evenodd" d="M7.5 6a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM3.751 20.105a8.25 8.25 0 0116.498 0 .75.75 0 01-.437.695A18.683 18.683 0 0112 22.5c-2.786 0-5.433-.608-7.812-1.7a.75.75 0 01-.437-.695z" clip-rule="evenodd" /></svg>''',
    'coin': '''<svg class="icon" viewBox="0 0 1114 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200"><path d="M807.511 400.666a512 512 0 0 0-60.15-53.873c-3.072-2.345-5.427-3.983-8.15-5.98 38.066-13.077 64.7-44.38 64.7-81.434 0-49.9-47.37-88.08-103.618-88.08a99.4 99.4 0 0 0-35.558 6.498 79 79 0 0 0-11.771 5.591c-1.966.83-6.16-.097-7.312-1.53l-.05.035c-4.291-6.43-10.763-14.402-20.168-22.569-17.9-15.554-39.092-25.15-63.294-25.15s-45.384 9.596-63.288 25.15c-9.19 7.977-15.498 15.713-19.804 22.078l-.026-.02c-1.628 1.92-5.852 2.928-7.322 2.221a78.4 78.4 0 0 0-12.144-5.811 99.5 99.5 0 0 0-35.564-6.502c-56.248 0-103.613 38.185-103.613 88.079 0 31.683 19.543 59.105 48.957 74.624a495 495 0 0 0-9.405 6.84 468 468 0 0 0-60.058 53.315C244.265 452.956 210.5 520.212 210.5 594.872c0 207.022 154.28 305.48 340.131 305.48 77.891 0 154.03-15.54 215.64-52.219 83.599-49.792 131.153-133.427 131.153-253.26-.015-70.165-33.996-135.348-89.912-194.207M646.564 601.43c10.598 0 19.184 8.791 19.184 19.615 0 10.829-8.59 19.625-19.184 19.625H569.81v56.489c0 8.289-8.591 15.006-19.185 15.006-10.598 0-19.184-6.717-19.184-15.006v-56.49h-76.754c-10.599 0-19.185-8.79-19.185-19.62s8.591-19.614 19.185-19.614h76.754V581.82h-76.754c-10.599 0-19.185-8.785-19.185-19.614s8.591-19.615 19.185-19.615h78.397l-72.78-74.399a19.917 19.917 0 0 1 0-27.735 18.893 18.893 0 0 1 27.135 0l63.186 64.584 63.186-64.584a18.903 18.903 0 0 1 26.721-.425l.42.425a19.927 19.927 0 0 1 0 27.735l-72.78 74.399h78.402c10.598 0 19.18 8.78 19.18 19.615s-8.587 19.614-19.18 19.614h-76.759v19.61z" fill="#f59e0b"/></svg>'''
}


def generate_html_report(results):
    """ç”Ÿæˆ HTML ç­¾åˆ°æŠ¥å‘Š"""
    now_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    success_count = len([r for r in results if r['status']])
    total_count = len(results)
    
    # åŸºç¡€æ ·å¼
    style_block = """
    <style>
        :root {
            --bg-body: #f9fafb;
            --bg-card: #ffffff;
            --text-main: #111827;
            --text-sub: #6b7280;
            --border: #e5e7eb;
            --bg-success: #ecfdf5;
            --text-success: #059669;
            --bg-error: #fef2f2;
            --text-error: #dc2626;
            --bg-footer: #f3f4f6;
            --text-footer: #9ca3af;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-body: #18181b;
                --bg-card: #27272a;
                --text-main: #f3f4f6;
                --text-sub: #9ca3af;
                --border: #3f3f46;
                --bg-success: #064e3b;
                --text-success: #34d399;
                --bg-error: #7f1d1d;
                --text-error: #f87171;
                --bg-footer: #1f2937;
                --text-footer: #6b7280;
            }
        }
        .container { max-width: 600px; margin: 0 auto; background-color: var(--bg-body); border-radius: 16px; overflow: hidden; border: 1px solid var(--border); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
        .header { background-color: var(--bg-card); padding: 24px; border-bottom: 1px solid var(--border); }
        .title { margin: 0; color: var(--text-main); font-size: 20px; font-weight: 700; display: flex; align-items: center; gap: 8px; }
        .subtitle { margin-top: 8px; color: var(--text-sub); font-size: 13px; font-weight: 500;}
        .badges { margin-top: 16px; display: flex; gap: 8px; }
        .badge-success { background-color: var(--bg-success); color: var(--text-success); padding: 4px 12px; border-radius: 20px; font-size: 13px; font-weight: 600; }
        .badge-error { background-color: var(--bg-error); color: var(--text-error); padding: 4px 12px; border-radius: 20px; font-size: 13px; font-weight: 600; }
        .content { padding: 16px; background-color: var(--bg-body); }
        .card { background-color: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 12px; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06); }
        .row-item { display: flex; align-items: center; gap: 6px; }
        .footer { background-color: var(--bg-body); padding: 20px; text-align: center; font-size: 12px; color: var(--text-footer); }
        /* Fix SVG size */
        svg { width: 20px; height: 20px; display: block; }
    </style>
    """
    
    html = f"""
    {style_block}
    <div class="container">
        <div class="header">
            <h3 class="title">
                ğŸŒ§ï¸ é›¨äº‘ç­¾åˆ°æŠ¥å‘Š
            </h3>
            <div class="subtitle">
                {now_str}
            </div>
            <div class="badges">
                <span class="badge-success">
                    æˆåŠŸ: {success_count}
                </span>
                <span class="badge-error">
                    å¤±è´¥: {total_count - success_count}
                </span>
            </div>
        </div>
        
        <div class="content">
    """
    
        
    for res in results:
        status_color = "var(--text-success)" if res['status'] else "var(--text-error)"
        status_bg = "var(--bg-success)" if res['status'] else "var(--bg-error)"
        
        points_element = ""
        if res.get('points'):
            points = res['points']
            money = points / 2000
            points_element = f"""
            <div class="row-item" style="color: #f59e0b; font-weight: 500;">
                {SVG_ICONS['coin']}
                <span>{points} (â‰ˆï¿¥{money:.2f})</span>
            </div>
            """
        else:
            # å¤±è´¥æ—¶æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            points_element = f"""
            <div class="row-item" style="color: var(--text-error);">
               <span>{res['msg']}</span>
            </div>
            """

        html += f"""
        <div class="card">
            <!-- ä¸ŠåŠéƒ¨åˆ†ï¼šç”¨æˆ·ä¿¡æ¯ + çŠ¶æ€å¾½æ ‡ -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <div class="row-item" style="font-weight: 600; font-size: 15px;">
                    {SVG_ICONS['user']}
                    <span>{res['username']}</span>
                </div>
                <span style="background-color: {status_bg}; color: {status_color}; padding: 2px 8px; border-radius: 6px; font-size: 12px; font-weight: 600;">
                    {'ç­¾åˆ°æˆåŠŸ' if res['status'] else 'ç­¾åˆ°å¤±è´¥'}
                </span>
            </div>
            
            <!-- åˆ†å‰²çº¿ -->
            <div style="height: 1px; background-color: var(--border); margin-bottom: 12px; opacity: 0.5;"></div>
            
            <!-- ä¸‹åŠéƒ¨åˆ†ï¼šç§¯åˆ†ä¿¡æ¯/é”™è¯¯ä¿¡æ¯ + æ›´å¤šç»†èŠ‚ -->
            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 13px;">
                {points_element}
                <div class="row-item" style="color: var(--text-sub); font-size: 12px;">
                    <span>é‡è¯•: {res.get('retries', 0)}</span>
                </div>
            </div>
        </div>
        """
        
    html += """
        </div>
        <div class="footer">
            Powered by Rainyun-Qiandao
        </div>
    </div>
    """
    return html


def generate_markdown_report(results):
    """ç”Ÿæˆ Markdown ç­¾åˆ°æŠ¥å‘Š"""
    now_str = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    success_count = len([r for r in results if r['status']])
    total_count = len(results)
    
    md = f"> {now_str}\n\n"
    md += f"**çŠ¶æ€**: âœ… {success_count} æˆåŠŸ / âŒ {total_count - success_count} å¤±è´¥\n\n"
    md += "---\n"
    
    for res in results:
        status_icon = "âœ…" if res['status'] else "âŒ"
        md += f"### {status_icon} {res['username']}\n"
        
        if res.get('points'):
            points = res['points']
            money = points / 2000
            md += f"- **ç§¯åˆ†**: {points} (â‰ˆï¿¥{money:.2f})\n"
        
        md += f"- **æ¶ˆæ¯**: {res['msg']}\n"
        if res.get('retries', 0) > 0:
            md += f"- **é‡è¯•**: {res['retries']}\n"
        md += "\n"
        
    md += "---\n"
    md += "Powered by Rainyun-Qiandao"
    return md


def send_pushplus_notification(token, title, content):
    """å‘é€ PushPlus é€šçŸ¥"""
    import requests
    url = 'http://www.pushplus.plus/send'
    data = {
        "token": token,
        "title": title,
        "content": content,
        "template": "html"
    }
    try:
        logging.info(f"Sending PushPlus notification: {title}")
        response = requests.post(url, json=data, timeout=10)
        result = response.json()
        if result.get('code') == 200:
            logging.info("PushPlus notification sent successfully")
            return True
        else:
            logging.error(f"PushPlus notification failed: {result.get('msg')}")
            return False
    except Exception as e:
        logging.error(f"Error sending PushPlus notification: {e}")
        return False


def parse_accounts():
    """è§£æå¤šè´¦å·é…ç½®"""
    usernames = os.getenv("RAINYUN_USERNAME", "").split("|")
    passwords = os.getenv("RAINYUN_PASSWORD", "").split("|")
    
    # ç¡®ä¿ç”¨æˆ·åå’Œå¯†ç æ•°é‡åŒ¹é…
    if len(usernames) != len(passwords):
        logger.warning("ç”¨æˆ·åå’Œå¯†ç æ•°é‡ä¸åŒ¹é…ï¼Œåªä½¿ç”¨åŒ¹é…çš„éƒ¨åˆ†")
        min_len = min(len(usernames), len(passwords))
        usernames = usernames[:min_len]
        passwords = passwords[:min_len]
    
    # è¿‡æ»¤ç©ºå€¼
    accounts = [(u.strip(), p.strip()) for u, p in zip(usernames, passwords) if u.strip() and p.strip()]
    
    if not accounts:
        # å¦‚æœæ²¡æœ‰å¤šè´¦å·é…ç½®ï¼Œä½¿ç”¨å•è´¦å·å…¼å®¹æ¨¡å¼
        single_user = os.getenv("RAINYUN_USERNAME", "username")
        single_pwd = os.getenv("RAINYUN_PASSWORD", "password")
        accounts = [(single_user, single_pwd)]
    
    logger.info(f"æ£€æµ‹åˆ° {len(accounts)} ä¸ªè´¦å·")
    for i, (username, _) in enumerate(accounts, 1):
        masked_user = f"{username[:3]}***{username[-3:] if len(username) > 6 else username}"
        logger.info(f"è´¦å· {i}: {masked_user}")
    
    return accounts


def run_all_accounts():
    """æ‰§è¡Œæ‰€æœ‰è´¦å·çš„ç­¾åˆ°ä»»åŠ¡"""
    # ä»»åŠ¡å¼€å§‹å‰æ¸…ç†å¯èƒ½çš„åƒµå°¸è¿›ç¨‹
    logger.info("æ£€æŸ¥å¹¶æ¸…ç†å¯èƒ½çš„åƒµå°¸è¿›ç¨‹...")
    cleanup_zombie_processes()
    
    accounts = parse_accounts()
    success_count = 0
    results = []
    
    for i, (username, password) in enumerate(accounts, 1):
        logger.info(f"========== å¼€å§‹æ‰§è¡Œç¬¬ {i}/{len(accounts)} ä¸ªè´¦å·ç­¾åˆ° ==========")
        result = run_checkin(username, password)
        results.append(result)
        
        if result['status']:
            success_count += 1
            logger.info(f"âœ… è´¦å· {i} ç­¾åˆ°æˆåŠŸ")
        else:
            logger.error(f"âŒ è´¦å· {i} ç­¾åˆ°å¤±è´¥")
        
        # æ¯ä¸ªè´¦å·æ‰§è¡Œåæ¸…ç†ä¸€æ¬¡
        cleanup_zombie_processes()
        
        # è´¦å·é—´å»¶æ—¶ï¼ˆé¿å…é¢‘ç¹æ“ä½œï¼‰
        if i < len(accounts):  # ä¸æ˜¯æœ€åä¸€ä¸ªè´¦å·
            delay = random.randint(30, 120)  # 30-120ç§’éšæœºå»¶æ—¶
            logger.info(f"è´¦å·é—´å»¶æ—¶ç­‰å¾… {delay} ç§’...")
            time.sleep(delay)
    
    # ç»Ÿè®¡ç»“æœå¹¶å‘é€é€šçŸ¥
    if accounts:
        # åˆå§‹åŒ–é€šçŸ¥ç®¡ç†å™¨
        notification_manager = NotificationManager()
        
        # æ³¨å†Œ PushPlus
        push_token = os.getenv("PUSHPLUS_TOKEN")
        if push_token:
            logger.info("Configuring PushPlus provider...")
            notification_manager.add_provider(PushPlusProvider(push_token))
            
        # æ³¨å†Œ WXPusher
        wx_app_token = os.getenv("WXPUSHER_APP_TOKEN")
        wx_uids = os.getenv("WXPUSHER_UIDS")
        if wx_app_token and wx_uids:
            logger.info("Configuring WXPusher provider...")
            notification_manager.add_provider(WXPusherProvider(wx_app_token, wx_uids))
            
        # æ³¨å†Œ DingTalk
        dingtalk_token = os.getenv("DINGTALK_ACCESS_TOKEN")
        dingtalk_secret = os.getenv("DINGTALK_SECRET")
        if dingtalk_token:
            logger.info("Configuring DingTalk provider...")
            notification_manager.add_provider(DingTalkProvider(dingtalk_token, dingtalk_secret))
            
        # æ³¨å†Œ Email
        smtp_host = os.getenv("SMTP_HOST")
        smtp_port = os.getenv("SMTP_PORT")
        smtp_user = os.getenv("SMTP_USER")
        smtp_pass = os.getenv("SMTP_PASS")
        smtp_to = os.getenv("SMTP_TO")
        
        if smtp_host and smtp_port and smtp_user and smtp_pass:
            # å¦‚æœæ²¡å¡«æ”¶ä»¶äººï¼Œé»˜è®¤å‘ç»™ç¬¬ä¸€ä¸ªç­¾åˆ°è´¦å·ï¼ˆå¦‚æœå®ƒæ˜¯é‚®ç®±çš„è¯ï¼‰
            if not smtp_to and accounts:
                first_account = accounts[0][0]
                if '@' in first_account:
                    smtp_to = first_account
                    logger.info(f"é…ç½®æç¤º: æœªå¡«å†™ SMTP_TOï¼Œå°†ä½¿ç”¨ç¬¬ä¸€ä¸ªé›¨äº‘è´¦å· ({smtp_to}) ä½œä¸ºæ”¶ä»¶äºº")
            
            if smtp_to:
                logger.info("Configuring Email provider...")
                notification_manager.add_provider(EmailProvider(smtp_host, smtp_port, smtp_user, smtp_pass, smtp_to))
            
        # å‘é€é€šçŸ¥
        if notification_manager.providers:
            logger.info("æ­£åœ¨ç”Ÿæˆè¯¦ç»†æ¨é€æŠ¥å‘Š...")
            html_content = generate_html_report(results)
            markdown_content = generate_markdown_report(results)
            
            context = {
                'html': html_content,
                'markdown': markdown_content
            }
            
            success_count = len([r for r in results if r['status']])
            title = f"é›¨äº‘ç­¾åˆ°: {success_count}/{len(accounts)} æˆåŠŸ"
            notification_manager.send_all(title, context)
    
    # ä»»åŠ¡ç»“æŸåå†æ¬¡æ¸…ç†
    logger.info("ä»»åŠ¡å®Œæˆï¼Œæ‰§è¡Œæœ€ç»ˆæ¸…ç†...")
    cleanup_zombie_processes()
    
    return success_count > 0


def init_selenium():
    # å¯¼å…¥Seleniumæ¨¡å—
    modules = import_selenium_modules()
    webdriver = modules['webdriver']
    Options = modules['Options']
    Service = modules['Service']
    
    ops = Options()
    ops.add_argument("--no-sandbox")
    ops.add_argument("--disable-dev-shm-usage")  # Docker ç¯å¢ƒä¼˜åŒ–
    ops.add_argument("--disable-extensions")
    ops.add_argument("--disable-plugins")
    
    # æ·»åŠ éšæœº User-Agent
    user_agent = get_random_user_agent()
    ops.add_argument(f"--user-agent={user_agent}")
    logger.info(f"ä½¿ç”¨ User-Agent: {user_agent[:50]}...")  # åªæ˜¾ç¤ºå‰50ä¸ªå­—ç¬¦
    
    if debug:
        ops.add_experimental_option("detach", True)
    
    if linux:
        ops.add_argument("--headless")
        ops.add_argument("--disable-gpu")
        
        # Selenium å®˜æ–¹é•œåƒçš„ ChromeDriver è·¯å¾„
        chromedriver_path = "/usr/bin/chromedriver"
        
        logger.info(f"ä½¿ç”¨ Selenium é•œåƒçš„ ChromeDriver: {chromedriver_path}")
        service = Service(chromedriver_path)
        return webdriver.Chrome(service=service, options=ops)
    else:
        # Windows ç¯å¢ƒ
        service = Service("chromedriver.exe")
        return webdriver.Chrome(service=service, options=ops)


def download_image(url, filename):
    # å»¶è¿Ÿå¯¼å…¥requestsæ¨¡å—
    import requests
    
    os.makedirs("temp", exist_ok=True)
    response = requests.get(url, timeout=10)
    if response.status_code == 200:
        path = os.path.join("temp", filename)
        with open(path, "wb") as f:
            f.write(response.content)
        return True
    else:
        logger.error("ä¸‹è½½å›¾ç‰‡å¤±è´¥ï¼")
        return False


def get_url_from_style(style):
    import re
    return re.search(r'url\(["\']?(.*?)["\']?\)', style).group(1)


def get_width_from_style(style):
    import re
    return re.search(r'width:\s*([\d.]+)px', style).group(1)


def get_height_from_style(style):
    import re
    return re.search(r'height:\s*([\d.]+)px', style).group(1)


def process_captcha(driver, timeout, retry_stats=None):
    """å¤„ç†éªŒè¯ç ï¼ˆå»¶è¿ŸåŠ è½½OCRæ¨¡å‹ï¼‰"""
    # å¯¼å…¥Seleniumæ¨¡å—
    modules = import_selenium_modules()
    WebDriverWait = modules['WebDriverWait']
    EC = modules['EC']
    By = modules['By']
    ActionChains = modules['ActionChains']
    TimeoutException = modules['TimeoutException']
    
    if retry_stats is None:
        retry_stats = {'count': 0}
    
    try:
        wait = WebDriverWait(driver, min(timeout, 3))
        try:
            wait.until(EC.presence_of_element_located((By.ID, "slideBg")))
        except TimeoutException:
            logger.info("æœªæ£€æµ‹åˆ°å¯å¤„ç†éªŒè¯ç å†…å®¹ï¼Œè·³è¿‡éªŒè¯ç å¤„ç†")
            return

        # å»¶è¿Ÿå¯¼å…¥ï¼Œåªåœ¨éœ€è¦æ—¶åŠ è½½
        import cv2
        import ddddocr

        logger.info("åˆå§‹åŒ–ddddocr")
        ocr = ddddocr.DdddOcr(ocr=True, show_ad=False)
        det = ddddocr.DdddOcr(det=True, show_ad=False)
        
        wait = WebDriverWait(driver, timeout)
        download_captcha_img(driver, timeout)
        if check_captcha(ocr):
            logger.info("å¼€å§‹è¯†åˆ«éªŒè¯ç ")
            captcha = cv2.imread("temp/captcha.jpg")
            with open("temp/captcha.jpg", 'rb') as f:
                captcha_b = f.read()
            bboxes = det.detection(captcha_b)
            result = dict()
            for i in range(len(bboxes)):
                x1, y1, x2, y2 = bboxes[i]
                spec = captcha[y1:y2, x1:x2]
                cv2.imwrite(f"temp/spec_{i + 1}.jpg", spec)
                for j in range(3):
                    similarity, matched = compute_similarity(f"temp/sprite_{j + 1}.jpg", f"temp/spec_{i + 1}.jpg")
                    similarity_key = f"sprite_{j + 1}.similarity"
                    position_key = f"sprite_{j + 1}.position"
                    if similarity_key in result.keys():
                        if float(result[similarity_key]) < similarity:
                            result[similarity_key] = similarity
                            result[position_key] = f"{int((x1 + x2) / 2)},{int((y1 + y2) / 2)}"
                    else:
                        result[similarity_key] = similarity
                        result[position_key] = f"{int((x1 + x2) / 2)},{int((y1 + y2) / 2)}"
            if check_answer(result):
                for i in range(3):
                    similarity_key = f"sprite_{i + 1}.similarity"
                    position_key = f"sprite_{i + 1}.position"
                    positon = result[position_key]
                    logger.info(f"å›¾æ¡ˆ {i + 1} ä½äº ({positon})ï¼ŒåŒ¹é…ç‡ï¼š{result[similarity_key]}")
                    slideBg = wait.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="slideBg"]')))
                    style = slideBg.get_attribute("style")
                    x, y = int(positon.split(",")[0]), int(positon.split(",")[1])
                    width_raw, height_raw = captcha.shape[1], captcha.shape[0]
                    width, height = float(get_width_from_style(style)), float(get_height_from_style(style))
                    x_offset, y_offset = float(-width / 2), float(-height / 2)
                    final_x, final_y = int(x_offset + x / width_raw * width), int(y_offset + y / height_raw * height)
                    ActionChains(driver).move_to_element_with_offset(slideBg, final_x, final_y).click().perform()
                confirm = wait.until(
                    EC.element_to_be_clickable((By.XPATH, '//*[@id="tcStatus"]/div[2]/div[2]/div/div')))
                logger.info("æäº¤éªŒè¯ç ")
                confirm.click()
                time.sleep(5)
                result = wait.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="tcOperation"]')))
                if result.get_attribute("class") == 'tc-opera pointer show-success':
                    logger.info("éªŒè¯ç é€šè¿‡")
                    return
                else:
                    logger.error("éªŒè¯ç æœªé€šè¿‡ï¼Œæ­£åœ¨é‡è¯•")
                    retry_stats['count'] += 1
            else:
                logger.error("éªŒè¯ç è¯†åˆ«å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•")
                retry_stats['count'] += 1
        else:
            logger.error("å½“å‰éªŒè¯ç è¯†åˆ«ç‡ä½ï¼Œå°è¯•åˆ·æ–°")
            retry_stats['count'] += 1
        
        reload = driver.find_element(By.XPATH, '//*[@id="reload"]')
        time.sleep(5)
        reload.click()
        time.sleep(5)
        process_captcha(driver, timeout, retry_stats)
    except TimeoutException:
        logger.error("è·å–éªŒè¯ç å›¾ç‰‡å¤±è´¥")
    finally:
        # å‡½æ•°ç»“æŸåï¼ŒOCRæ¨¡å‹ä¼šè‡ªåŠ¨é‡Šæ”¾å†…å­˜
        logger.debug("éªŒè¯ç å¤„ç†å®Œæˆï¼ŒOCR æ¨¡å‹å°†è¢«é‡Šæ”¾")


def download_captcha_img(driver, timeout):
    # å¯¼å…¥Seleniumæ¨¡å—
    modules = import_selenium_modules()
    WebDriverWait = modules['WebDriverWait']
    EC = modules['EC']
    By = modules['By']
    
    wait = WebDriverWait(driver, timeout)
    if os.path.exists("temp"):
        for filename in os.listdir("temp"):
            file_path = os.path.join("temp", filename)
            if os.path.isfile(file_path) or os.path.islink(file_path):
                os.remove(file_path)
    slideBg = wait.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="slideBg"]')))
    img1_style = slideBg.get_attribute("style")
    img1_url = get_url_from_style(img1_style)
    logger.info("å¼€å§‹ä¸‹è½½éªŒè¯ç å›¾ç‰‡(1): " + img1_url)
    download_image(img1_url, "captcha.jpg")
    sprite = wait.until(EC.visibility_of_element_located((By.XPATH, '//*[@id="instruction"]/div/img')))
    img2_url = sprite.get_attribute("src")
    logger.info("å¼€å§‹ä¸‹è½½éªŒè¯ç å›¾ç‰‡(2): " + img2_url)
    download_image(img2_url, "sprite.jpg")


def check_captcha(ocr) -> bool:
    """æ£€æŸ¥éªŒè¯ç å›¾ç‰‡è´¨é‡ï¼ˆå»¶è¿Ÿå¯¼å…¥cv2ï¼‰"""
    import cv2
    
    raw = cv2.imread("temp/sprite.jpg")
    for i in range(3):
        w = raw.shape[1]
        temp = raw[:, w // 3 * i: w // 3 * (i + 1)]
        cv2.imwrite(f"temp/sprite_{i + 1}.jpg", temp)
        with open(f"temp/sprite_{i + 1}.jpg", mode="rb") as f:
            temp_rb = f.read()
        if ocr.classification(temp_rb) in ["0", "1"]:
            return False
    return True


# æ£€æŸ¥æ˜¯å¦å­˜åœ¨é‡å¤åæ ‡ï¼Œå¿«é€Ÿåˆ¤æ–­è¯†åˆ«é”™è¯¯
def check_answer(d: dict) -> bool:
    flipped = dict()
    for key in d.keys():
        flipped[d[key]] = key
    return len(d.values()) == len(flipped.keys())


def compute_similarity(img1_path, img2_path):
    """è®¡ç®—å›¾ç‰‡ç›¸ä¼¼åº¦ï¼ˆå»¶è¿Ÿå¯¼å…¥cv2ï¼‰"""
    import cv2
    
    img1 = cv2.imread(img1_path, cv2.IMREAD_GRAYSCALE)
    img2 = cv2.imread(img2_path, cv2.IMREAD_GRAYSCALE)

    sift = cv2.SIFT_create()
    kp1, des1 = sift.detectAndCompute(img1, None)
    kp2, des2 = sift.detectAndCompute(img2, None)

    if des1 is None or des2 is None:
        return 0.0, 0

    bf = cv2.BFMatcher()
    matches = bf.knnMatch(des1, des2, k=2)

    good = [m for m_n in matches if len(m_n) == 2 for m, n in [m_n] if m.distance < 0.8 * n.distance]

    if len(good) == 0:
        return 0.0, 0

    similarity = len(good) / len(matches)
    return similarity, len(good)


def dismiss_modal_confirm(driver, timeout):
    modules = import_selenium_modules()
    WebDriverWait = modules['WebDriverWait']
    EC = modules['EC']
    By = modules['By']
    TimeoutException = modules['TimeoutException']

    wait = WebDriverWait(driver, min(timeout, 5))
    try:
        confirm = wait.until(
            EC.element_to_be_clickable(
                (By.XPATH, "//footer[contains(@id,'modal') and contains(@id,'footer')]//button[contains(normalize-space(.), 'ç¡®è®¤')]")
            )
        )
        try:
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", confirm)
        except Exception:
            pass
        time.sleep(0.2)
        confirm.click()
        logger.info("å·²å…³é—­å¼¹çª—ï¼šç¡®è®¤")
        time.sleep(0.5)
        return True
    except TimeoutException:
        return False
    except Exception:
        try:
            confirm = driver.find_element(By.XPATH, "//button[contains(normalize-space(.), 'ç¡®è®¤') and contains(@class,'btn')]")
            driver.execute_script("arguments[0].click();", confirm)
            logger.info("å·²å…³é—­å¼¹çª—ï¼šç¡®è®¤")
            time.sleep(0.5)
            return True
        except Exception:
            return False


def wait_captcha_or_modal(driver, timeout):
    modules = import_selenium_modules()
    WebDriverWait = modules['WebDriverWait']
    EC = modules['EC']
    By = modules['By']
    TimeoutException = modules['TimeoutException']

    def find_visible_tcaptcha_iframe():
        try:
            iframes = driver.find_elements(By.CSS_SELECTOR, "iframe[id^='tcaptcha_iframe']")
        except Exception:
            return None
        for fr in iframes:
            try:
                if fr.is_displayed() and fr.size.get("width", 0) > 0 and fr.size.get("height", 0) > 0:
                    return fr
            except Exception:
                continue
        return None

    end_time = time.time() + min(timeout, 8)
    while time.time() < end_time:
        if dismiss_modal_confirm(driver, timeout):
            return "modal"
        try:
            iframe = find_visible_tcaptcha_iframe()
            if iframe:
                return "captcha"
        except Exception:
            pass
        time.sleep(0.3)
    return "none"


def run_checkin(account_user=None, account_pwd=None):
    """æ‰§è¡Œç­¾åˆ°ä»»åŠ¡"""
    # å¯¼å…¥Seleniumæ¨¡å—
    modules = import_selenium_modules()
    webdriver = modules['webdriver']
    ActionChains = modules['ActionChains']
    Options = modules['Options']
    Service = modules['Service']
    WebDriver = modules['WebDriver']
    By = modules['By']
    EC = modules['EC']
    WebDriverWait = modules['WebDriverWait']
    TimeoutException = modules['TimeoutException']
    import subprocess
    
    current_user = account_user or user
    current_pwd = account_pwd or pwd
    driver = None  # åˆå§‹åŒ–ä¸º Noneï¼Œç¡®ä¿åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½èƒ½å®‰å…¨æ¸…ç†
    retry_stats = {'count': 0}
    
    try:
        logger.info(f"å¼€å§‹æ‰§è¡Œç­¾åˆ°ä»»åŠ¡... è´¦å·: {current_user[:5]}***{current_user[-5:] if len(current_user) > 10 else current_user}")
        
        # éšæœºå»¶æ—¶
        delay = random.randint(0, max_delay)
        delay_sec = random.randint(0, 60)
        if not debug:
            logger.info(f"éšæœºå»¶æ—¶ç­‰å¾… {delay} åˆ†é’Ÿ {delay_sec} ç§’")
            time.sleep(delay * 60 + delay_sec)
        
        logger.info("åˆå§‹åŒ– Selenium")
        driver = init_selenium()
        
        # è¿‡ Selenium æ£€æµ‹
        with open("stealth.min.js", mode="r") as f:
            js = f.read()
        driver.execute_cdp_cmd("Page.addScriptToEvaluateOnNewDocument", {
            "source": js
        })
        
        logger.info("å‘èµ·ç™»å½•è¯·æ±‚")
        driver.get("https://app.rainyun.com/auth/login")
        wait = WebDriverWait(driver, timeout)
        
        try:
            username = wait.until(EC.visibility_of_element_located((By.NAME, 'login-field')))
            password = wait.until(EC.visibility_of_element_located((By.NAME, 'login-password')))
            login_button = wait.until(EC.visibility_of_element_located((By.XPATH,
                                                                        '//*[@id="app"]/div[1]/div[1]/div/div[2]/fade/div/div/span/form/button')))
            username.send_keys(current_user)
            password.send_keys(current_pwd)
            login_button.click()
        except TimeoutException:
            logger.error("é¡µé¢åŠ è½½è¶…æ—¶ï¼Œè¯·å°è¯•å»¶é•¿è¶…æ—¶æ—¶é—´æˆ–åˆ‡æ¢åˆ°å›½å†…ç½‘ç»œç¯å¢ƒï¼")
            return {
                'status': False,
                'msg': 'é¡µé¢åŠ è½½è¶…æ—¶',
                'points': 0,
                'username': f"{current_user[:3]}***{current_user[-3:] if len(current_user) > 6 else current_user}",
                'retries': retry_stats['count']
            }
        
        try:
            login_captcha = wait.until(EC.visibility_of_element_located((By.ID, 'tcaptcha_iframe_dy')))
            logger.warning("è§¦å‘éªŒè¯ç ï¼")
            driver.switch_to.frame("tcaptcha_iframe_dy")
            process_captcha(driver, timeout, retry_stats)
        except TimeoutException:
            logger.info("æœªè§¦å‘éªŒè¯ç ")
        
        time.sleep(5)
        driver.switch_to.default_content()
        dismiss_modal_confirm(driver, timeout)
        
        if driver.current_url == "https://app.rainyun.com/dashboard":
            logger.info("ç™»å½•æˆåŠŸï¼")
            logger.info("æ­£åœ¨è½¬åˆ°èµšå–ç§¯åˆ†é¡µ")
            driver.get("https://app.rainyun.com/account/reward/earn")
            driver.implicitly_wait(5)
            time.sleep(1)
            dismiss_modal_confirm(driver, timeout)
            dismiss_modal_confirm(driver, timeout)
            
            earn = driver.find_element(By.XPATH,
                                       '//*[@id="app"]/div[1]/div[3]/div[2]/div/div/div[2]/div[2]/div/div/div/div[1]/div/div[1]/div/div[1]/div/span[2]/a')
            logger.info("ç‚¹å‡»èµšå–ç§¯åˆ†")
            earn.click()
            state = wait_captcha_or_modal(driver, timeout)
            if state == "captcha":
                logger.info("å¤„ç†éªŒè¯ç ")
                try:
                    captcha_iframe = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "iframe[id^='tcaptcha_iframe']")))
                    driver.switch_to.frame(captcha_iframe)
                    process_captcha(driver, timeout, retry_stats)
                finally:
                    driver.switch_to.default_content()
                driver.implicitly_wait(5)
            else:
                logger.info("æœªè§¦å‘éªŒè¯ç ï¼ˆèµšå–ç§¯åˆ†ï¼‰")
            
            points_raw = driver.find_element(By.XPATH,
                                             '//*[@id="app"]/div[1]/div[3]/div[2]/div/div/div[2]/div[1]/div[1]/div/p/div/h3').get_attribute(
                "textContent")
            import re
            current_points = int(''.join(re.findall(r'\d+', points_raw)))
            logger.info(f"å½“å‰å‰©ä½™ç§¯åˆ†: {current_points} | çº¦ä¸º {current_points / 2000:.2f} å…ƒ")
            logger.info("ç­¾åˆ°ä»»åŠ¡æ‰§è¡ŒæˆåŠŸï¼")
            return {
                'status': True,
                'msg': 'ç­¾åˆ°æˆåŠŸ',
                'points': current_points,
                'username': f"{current_user[:3]}***{current_user[-3:] if len(current_user) > 6 else current_user}",
                'retries': retry_stats['count']
            }
        else:
            logger.error("ç™»å½•å¤±è´¥ï¼")
            return {
                'status': False,
                'msg': 'ç™»å½•å¤±è´¥',
                'points': 0,
                'username': f"{current_user[:3]}***{current_user[-3:] if len(current_user) > 6 else current_user}",
                'retries': retry_stats['count']
            }
            
    except Exception as e:
        logger.error(f"ç­¾åˆ°ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {e}")
        import traceback
        logger.error(f"è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")
        return {
            'status': False,
            'msg': f'æ‰§è¡Œå¼‚å¸¸: {str(e)[:50]}...',
            'points': 0,
            'username': f"{current_user[:3]}***{current_user[-3:] if len(current_user) > 6 else current_user}",
            'retries': retry_stats['count']
        }
    finally:
        # ç¡®ä¿åœ¨ä»»ä½•æƒ…å†µä¸‹éƒ½å…³é—­ WebDriver
        if driver is not None:
            try:
                logger.info("æ­£åœ¨å…³é—­ WebDriver...")
                
                # é¦–å…ˆå°è¯•æ­£å¸¸å…³é—­
                try:
                    driver.quit()
                    logger.info("WebDriver å·²å®‰å…¨å…³é—­")
                except Exception as e:
                    logger.error(f"å…³é—­ WebDriver æ—¶å‡ºé”™: {e}")
                
                # ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©è¿›ç¨‹å®Œå…¨é€€å‡º
                time.sleep(1)
                
                # å¼ºåˆ¶ç»ˆæ­¢ ChromeDriver è¿›ç¨‹åŠå…¶å­è¿›ç¨‹
                try:
                    if hasattr(driver, 'service') and driver.service.process:
                        process = driver.service.process
                        if process.poll() is None:  # è¿›ç¨‹ä»åœ¨è¿è¡Œ
                            # ç»ˆæ­¢è¿›ç¨‹
                            process.terminate()
                            try:
                                # ç­‰å¾…æœ€å¤š2ç§’
                                process.wait(timeout=2)
                            except subprocess.TimeoutExpired:
                                # å¦‚æœè¿˜æ²¡é€€å‡ºï¼Œå¼ºåˆ¶kill
                                process.kill()
                                process.wait()
                            logger.info("å·²ç»ˆæ­¢ ChromeDriver è¿›ç¨‹")
                except Exception as e:
                    logger.debug(f"æ¸…ç† ChromeDriver è¿›ç¨‹æ—¶å‡ºé”™: {e}")
                
                # é¢å¤–ä¿é™©ï¼šæ¸…ç†å¯èƒ½æ®‹ç•™çš„Chromeè¿›ç¨‹
                if os.name == 'posix':
                    try:
                        subprocess.run(['pkill', '-9', '-f', 'chrome.*--test-type'], 
                                     timeout=3, stderr=subprocess.DEVNULL)
                    except:
                        pass
                        
            except Exception as e:
                logger.error(f"WebDriver æ¸…ç†è¿‡ç¨‹å‡ºç°å¼‚å¸¸: {e}")
        
        # å¸è½½Seleniumæ¨¡å—ï¼Œé‡Šæ”¾å†…å­˜
        try:
            unload_selenium_modules()
            logger.debug("å·²å¸è½½Seleniumæ¨¡å—")
        except:
            pass


def scheduled_checkin():
    """å®šæ—¶ä»»åŠ¡åŒ…è£…å™¨"""
    logger.info(f"å®šæ—¶ä»»åŠ¡è§¦å‘ - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    success = run_all_accounts()
    
    if success:
        logger.info("å®šæ—¶ç­¾åˆ°ä»»åŠ¡æ‰§è¡ŒæˆåŠŸï¼")
    else:
        logger.error("å®šæ—¶ç­¾åˆ°ä»»åŠ¡æ‰§è¡Œå¤±è´¥ï¼")
    
    # æ˜¾ç¤ºä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
    logger.info("å®šæ—¶ä»»åŠ¡å®Œæˆï¼ŒæŸ¥çœ‹ä¸‹æ¬¡æ‰§è¡Œå®‰æ’...")
    time.sleep(1)  # ç»™scheduleæ—¶é—´æ›´æ–°
    
    # æ‰‹åŠ¨è®¡ç®—ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´ï¼Œç¡®ä¿æ˜¯æœªæ¥æ—¶é—´
    schedule_time = os.getenv("SCHEDULE_TIME", "08:00")
    current_time = datetime.now()
    next_run = current_time.replace(
        hour=int(schedule_time.split(':')[0]), 
        minute=int(schedule_time.split(':')[1]), 
        second=0, 
        microsecond=0
    )
    
    # å¦‚æœè®¡ç®—å‡ºçš„æ—¶é—´å·²ç»è¿‡å»ï¼Œåˆ™æ¨åˆ°ä¸‹ä¸€å¤©
    if next_run <= current_time:
        next_run += timedelta(days=1)
    
    logger.info(f"âœ… ç¨‹åºç»§ç»­è¿è¡Œï¼Œä¸‹æ¬¡æ‰§è¡Œæ—¶é—´: {next_run.strftime('%Y-%m-%d %H:%M:%S')}")
    time_diff = next_run - current_time
    hours, remainder = divmod(time_diff.total_seconds(), 3600)
    minutes, _ = divmod(remainder, 60)
    logger.info(f"è·ç¦»ä¸‹æ¬¡æ‰§è¡Œè¿˜æœ‰: {int(hours)}å°æ—¶{int(minutes)}åˆ†é’Ÿ")
    
    return success


if __name__ == "__main__":
    # é…ç½®å‚æ•°
    timeout = int(os.getenv("TIMEOUT", "15000")) // 1000  # è½¬æ¢ä¸ºç§’
    max_delay = int(os.getenv("MAX_DELAY", "5"))
    debug = os.getenv("DEBUG", "false").lower() == "true"
    linux = os.getenv("LINUX_MODE", "true").lower() == "true" or os.path.exists("/.dockerenv")
    
    # å…¼å®¹æ€§å˜é‡ï¼ˆä¾›å•è´¦å·æ¨¡å¼ä½¿ç”¨ï¼‰
    user = os.getenv("RAINYUN_USERNAME", "username").split("|")[0]
    pwd = os.getenv("RAINYUN_PASSWORD", "password").split("|")[0]
    
    # è¿è¡Œæ¨¡å¼ï¼ˆonce: è¿è¡Œä¸€æ¬¡, schedule: å®šæ—¶è¿è¡Œï¼‰
    run_mode = os.getenv("RUN_MODE", "schedule")
    # å®šæ—¶æ‰§è¡Œæ—¶é—´ï¼ˆé»˜è®¤æ—©ä¸Š8ç‚¹ï¼‰
    schedule_time = os.getenv("SCHEDULE_TIME", "08:00")

    # åˆå§‹åŒ–æ—¥å¿—ï¼ˆä½¿ç”¨æ–°çš„æ—¥å¿—è½®è½¬åŠŸèƒ½ï¼‰
    logger = setup_logging()
    ver = "2.2-docker-notify"
    logger.info("------------------------------------------------------------------")
    logger.info(f"é›¨äº‘ç­¾åˆ°å·¥å…· v{ver} by LeapYa ~")
    logger.info("Githubå‘å¸ƒé¡µ: https://github.com/LeapYa/Rainyun-Qiandao")
    logger.info("------------------------------------------------------------------")
    logger.info("å·²å¯ç”¨æ—¥å¿—è½®è½¬åŠŸèƒ½ï¼Œå°†è‡ªåŠ¨æ¸…ç†7å¤©å‰çš„æ—¥å¿—")
    if debug:
        logger.info(f"å½“å‰é…ç½®: MAX_DELAY={max_delay}åˆ†é’Ÿ, TIMEOUT={timeout}ç§’")

    
    # ç¨‹åºå¯åŠ¨æ—¶æ‰§è¡Œæ—¥å¿—æ¸…ç†
    cleanup_logs_on_startup()
    
    # è®¾ç½®å­è¿›ç¨‹è‡ªåŠ¨å›æ”¶æœºåˆ¶ï¼ˆå¿…é¡»åœ¨å¯åŠ¨ä»»ä½•å­è¿›ç¨‹ä¹‹å‰ï¼‰
    setup_sigchld_handler()
    
    # ç¨‹åºå¯åŠ¨æ—¶æ¸…ç†å¯èƒ½æ®‹ç•™çš„åƒµå°¸è¿›ç¨‹
    logger.info("ç¨‹åºå¯åŠ¨ï¼Œæ£€æŸ¥ç³»ç»Ÿä¸­çš„åƒµå°¸è¿›ç¨‹...")
    cleanup_zombie_processes()
    
    if run_mode == "schedule":
        # å®šæ—¶æ¨¡å¼
        logger.info(f"å¯åŠ¨å®šæ—¶æ¨¡å¼ï¼Œæ¯å¤© {schedule_time} è‡ªåŠ¨æ‰§è¡Œç­¾åˆ°")
        logger.info("ç¨‹åºå°†æŒç»­è¿è¡Œï¼ŒæŒ‰ Ctrl+C é€€å‡º")
        
        # è®¾ç½®æ¯æ—¥å®šæ—¶ä»»åŠ¡
        schedule.every().day.at(schedule_time).do(scheduled_checkin)
        
        # æ˜¾ç¤ºæ¯æ—¥å®šæ—¶ä»»åŠ¡æ—¶é—´
        tomorrow_schedule = datetime.now().replace(hour=int(schedule_time.split(':')[0]), 
                                                  minute=int(schedule_time.split(':')[1]), 
                                                  second=0, microsecond=0)
        if tomorrow_schedule <= datetime.now():
            tomorrow_schedule += timedelta(days=1)
        logger.info(f"æ¯æ—¥æ‰§è¡Œæ—¶é—´: {tomorrow_schedule.strftime('%Y-%m-%d %H:%M:%S')}")
        
        # é¦–æ¬¡å¯åŠ¨1åˆ†é’Ÿåæ‰§è¡Œä¸€æ¬¡
        logger.info("é¦–æ¬¡å¯åŠ¨ï¼Œå°†åœ¨1åˆ†é’Ÿåæ‰§è¡Œé¦–æ¬¡ç­¾åˆ°ä»»åŠ¡")
        first_run_time = datetime.now() + timedelta(minutes=1)
        logger.info(f"é¦–æ¬¡æ‰§è¡Œæ—¶é—´: {first_run_time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        # æŒç»­è¿è¡Œæ£€æŸ¥å®šæ—¶ä»»åŠ¡
        logger.info("è°ƒåº¦å™¨å·²å¯åŠ¨ï¼Œç­‰å¾…æ‰§è¡Œä»»åŠ¡...")
        first_run_done = False
        
        try:
            while True:
                current_time = datetime.now()
                
                # æ£€æŸ¥æ˜¯å¦åˆ°äº†é¦–æ¬¡æ‰§è¡Œæ—¶é—´
                if not first_run_done and current_time >= first_run_time:
                    logger.info("æ‰§è¡Œé¦–æ¬¡ç­¾åˆ°ä»»åŠ¡ï¼ˆæ‰€æœ‰è´¦å·ï¼‰")
                    success = run_all_accounts()
                    if success:
                        logger.info("é¦–æ¬¡ç­¾åˆ°ä»»åŠ¡æ‰§è¡ŒæˆåŠŸï¼")
                    else:
                        logger.error("é¦–æ¬¡ç­¾åˆ°ä»»åŠ¡æ‰§è¡Œå¤±è´¥ï¼")
                    
                    # æ˜¾ç¤ºä¸‹æ¬¡æ‰§è¡Œæ—¶é—´
                    logger.info("é¦–æ¬¡ä»»åŠ¡å®Œæˆï¼ŒæŸ¥çœ‹ä¸‹æ¬¡æ‰§è¡Œå®‰æ’...")
                    logger.info(f"âœ… ç¨‹åºå°†ç»§ç»­è¿è¡Œï¼Œä¸‹æ¬¡æ‰§è¡Œæ—¶é—´: {tomorrow_schedule.strftime('%Y-%m-%d %H:%M:%S')}")
                    time_diff = tomorrow_schedule - datetime.now()
                    hours, remainder = divmod(time_diff.total_seconds(), 3600)
                    minutes, _ = divmod(remainder, 60)
                    logger.info(f"è·ç¦»ä¸‹æ¬¡æ‰§è¡Œè¿˜æœ‰: {int(hours)}å°æ—¶{int(minutes)}åˆ†é’Ÿ")
                    
                    first_run_done = True  # æ ‡è®°é¦–æ¬¡ä»»åŠ¡å·²å®Œæˆ
                
                # æ£€æŸ¥æ¯æ—¥å®šæ—¶ä»»åŠ¡
                schedule.run_pending()
                time.sleep(30)  # æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
                
        except KeyboardInterrupt:
            logger.info("ç¨‹åºå·²åœæ­¢")
    else:
        # å•æ¬¡è¿è¡Œæ¨¡å¼
        logger.info("è¿è¡Œæ¨¡å¼: å•æ¬¡æ‰§è¡Œï¼ˆæ‰€æœ‰è´¦å·ï¼‰")
        success = run_all_accounts()
        if success:
            logger.info("ç¨‹åºæ‰§è¡Œå®Œæˆ")
        else:
            logger.error("ç¨‹åºæ‰§è¡Œå¤±è´¥")